
### Este exame será retirado em 31 de janeiro de 2021 às 23h59, horário central. Você não poderá mais fazer o exame após essa data. Saiba mais sobre outros exames que serão retirados [aqui](https://docs.microsoft.com/en-us/learn/certifications/retired-certification-exams)


<ul>
{% for post in site.posts %}
<li>
<a href="{{ site.baseurl }}{{ post.url }}">{{ post.title }}</a>
</li>
{% endfor %}
</ul>


Resumo do treinamento para o exame................

1. [Criar_usar_tipos](https://github.com/shyoutarou/Exam-70-483_Criar_usar_tipos/wiki/Criar_usar_tipos)
     - [GitHub Page](https://shyoutarou.github.io/Exam-70-483_Criar_usar_tipos/)
2. [Gerenciar_fluxo](https://github.com/shyoutarou/Exam-70-483_Gerenciar_fluxo/wiki/Gerenciar_fluxo)
     - [GitHub Page](https://shyoutarou.github.io/Exam-70-483_Gerenciar_fluxo/)
3. [Acesso_dados](https://github.com/shyoutarou/Exam-70-483_Acesso_dados/wiki/Acesso_dados)
     - [GitHub Page](https://shyoutarou.github.io/Exam-70-483_Acesso_dados/)
4. [Depurar_segurança](https://github.com/shyoutarou/Exam-70-483_Depurar_seguranca/wiki/Depurar_seguranca)
     - [GitHub Page](https://shyoutarou.github.io/Exam-70-483_Depurar_seguranca/)
5. [Csharp8_Csharp9](https://github.com/shyoutarou/Exam-70-483_Csharp8_Csharp9/wiki/Csharp8_Csharp9)
     - [GitHub Page](https://shyoutarou.github.io/Exam-70-483_Csharp8_Csharp9/)
6. [Questions](https://github.com/shyoutarou/Exam-70-483_Questions/wiki/Questions)


## Usando reflexão 
- **Criar e aplicar atributos; ler atributos; gerar código em tempo de execução usando expressões CodeDom e lambda; usar tipos do namespace System.Reflection, incluindo Assembly, PropertyInfo, MethodInfo, Type**

- [Criando e usando atributos](#criando-e-usando-atributos)
- [Atributos de leitura (Veja mais exemplos na seção Reflexion, mais abaixo)](#atributos-de-leitura-veja-mais-exemplos-na-seção-reflexion-mais-abaixo)
- [Atributo personalizado (Custom)](#atributo-personalizado-custom)
- [Atributos xUnit](#atributos-xunit)
- [Escreva sua primeira teoria](#escreva-sua-primeira-teoria)
- [Expressões CodeDom](#expressões-codedom)
- [CodeCompileUnit](#codecompileunit)
- [CodeNamespace e CodeNamespaceImport](#codenamespace-e-codenamespaceimport)
- [CodeTypeDeclaration](#codetypedeclaration)
- [CodeMemberField](#codememberfield)
- [CodeMemberProperty](#codememberproperty)
- [CodeMemberMethod](#codemembermethod)
- [CodeParameterDeclarationExpression e CodeMethodInvokeExpression](#codeparameterdeclarationexpression-e-codemethodinvokeexpression)
- [CodeDOMProvider](#codedomprovider)
- [EXPRESSÕES LAMBDA](#expressões-lambda)
- [Delegates e Lambda](#delegates-e-lambda)
- [Métodos anônimos e Lambda](#métodos-anônimos-e-lambda)
- [Instruções Lambdas (Statement Lambdas)](#instruções-lambdas-statement-lambdas)
- [Árvores de expressão](#árvores-de-expressão)
- [Reflection](#reflection)
- [Obter informações do assembly (propriedades, métodos, eventos, interfaces, campos)](#obter-informações-do-assembly-propriedades-métodos-eventos-interfaces-campos)
- [Ler, Gravar e Invocar método de classe](#ler-gravar-e-invocar-método-de-classe)
- [Obter membros privados e membros estáticos de classe](#obter-membros-privados-e-membros-estáticos-de-classe)

Um aplicativo .NET não contém apenas código e dados; Ele também contém metadados, que são informações sobre dados. No .NET, isso significa que um aplicativo contém o código que define o aplicativo e os dados que descrevem o código. Um atributo é um tipo de metadado que pode ser armazenado em um aplicativo .NET. Outros tipos de metadados contêm informações sobre os tipos, código, montagem e todos os outros elementos armazenados no seu aplicativo. Reflexão é o processo de recuperar esses metadados em tempo de execução. Os dados podem ser inspecionados e usados para tomar decisões. 

### Criando e usando atributos

O uso de atributos é uma maneira poderosa de adicionar metadados a um aplicativo. Os atributos podem ser adicionados a todos os tipos: montagens, tipos, métodos, parâmetros e propriedades. No tempo de execução, você pode consultar a existência de um atributo e suas configurações e, em seguida, executar as ações apropriadas.Os atributos são usados por vários motivos. Eles podem ser usados para descrever as informações do autor de um assembly ou para fornecer dicas específicas ao compilador sobre como otimizar seu código. Atributos personalizados podem armazenar todos os tipos de dados que você deseja.

No C#, você aplica um atributo colocando-o entre colchetes ([]) acima da declaração à qual deseja aplicar o atributo.Um exemplo de atributo no .NET Framework é o atributo System.SerializableAttribute. Este atributo indica que um tipo pode ser serializado. O .NET Framework verifica a existência desse atributo ao serializar um tipo e garante que todos os membros do tipo também possam ser serializados. 

```csharp
[Serializable]
class Person
{
public string  FirstName { get; set; }
public string  LastName { get; set; }
}
```

Como você pode ver, a classe real no .NET Framework é chamada SerializableAttribute. Por convenção, o nome é sufixado com Attributepara que você possa distinguir facilmente entre atributos e outros tipos no .NET Framework. Ao usar o atributo, no entanto, você pode pular o sufixo do Attribute.

A serialização é o processo de converter um objeto em um fluxo de bytes para armazenar o objeto ou transmiti-lo para a memória, um banco de dados ou um arquivo. Sua finalidade principal é salvar o estado de um objeto para recriá-lo quando necessário. O processo inverso é chamado desserialização. Esta ilustração mostra o processo geral de serialização:
<p align="center">
  <img src="https://raw.githubusercontent.com/shyoutarou/Exam-70-483_Criar_usar_tipos/master/.github/objbyte2.png" alt="Image" width="300px" />
</p>
 


O objeto é serializado para um fluxo que carrega os dados. O fluxo também pode ter informações sobre o tipo do objeto, como sua versão, cultura e nome de montagem. A partir desse fluxo, o objeto pode ser armazenado em um banco de dados, um arquivo ou memória. A serialização permite que o desenvolvedor salve o estado de um objeto e o recrie conforme necessário, fornecendo armazenamento de objetos, bem como troca de dados. Através da serialização, um desenvolvedor pode executar ações como:
- Enviando o objeto para um aplicativo remoto usando um serviço web
- Passando um objeto de um domínio para outro
- Passando um objeto através de um firewall como uma seqüência JSON ou XML
- Manutenção de informações de segurança ou específicas do usuário entre aplicativos

```csharp
[Serializable]
class Person
{
    public string  Name { get; set; }
    public int Idade { get; set; }
    public double Altura { get; set; }

    // A field that is not serialized.
    [NonSerialized()] public string  Endereco;

    public Person()
    {
        Name = "Bob";
        Idade = 11;
        Altura = 1.74159265;
        Endereco = "Avenida Brasil";
    }

    public void Print()
    {
        Console.WriteLine("Name = '{0}'", Name);
        Console.WriteLine("Idade = '{0}'", Idade);
        Console.WriteLine("Altura = '{0}'", Altura);
        Console.WriteLine("NonSerialized Endereco = '{0}'", Endereco);
    }
}

// Creates a new TestSimpleObject object.
Person obj = new Person();

Console.WriteLine("Before serialization the object contains: ");
obj.Print();

// Opens a file and serializes the object into it in binary format.
Stream stream = File.Open("data.xml", FileMode.Create);

BinaryFormatter formatter = new BinaryFormatter();
formatter.Serialize(stream, obj);
stream.Close();

// Empties obj.
obj = null;

// Opens file "data.xml" and deserializes the object from it.
stream = File.Open("data.xml", FileMode.Open);
formatter = new BinaryFormatter();

obj = (Person)formatter.Deserialize(stream);
stream.Close();

Console.WriteLine("");
Console.WriteLine("After deserialization the object contains: ");
obj.Print();

//Before serialization the object contains:
//Name = 'Bob'
//Idade = '11'
//Altura = '1,74159265'
//NonSerialized Endereco = 'Avenida Brasil'

//After deserialization the object contains:
//Name = 'Bob'
//Idade = '11'
//Altura = '1,74159265'
//NonSerialized Endereco = ''
```

Um tipo pode ter tantos atributos aplicados quanto necessário. Alguns atributos podem até ser aplicados várias vezes. Por exemplo, você pode usar o ConditionalAttribute para indicar ao compilador que uma chamada de método deve ser ignorada, a menos que uma opção específica do compilador seja especificada. O exemplo abaixo mostra como aplicar esse atributo.
```csharp
[Conditional("CONDITION1"), Conditional("CONDITION2")]
 static void MyMethod() { }
```

Conforme mostrado na listagem, um atributo pode ter parâmetros. Assim como nos tipos regulares, esses parâmetros podem ser nomeados como opcionais. Os valores configurados para um atributo podem ser inspecionados posteriormente em tempo de execução.

O exemplo a seguir demonstra o uso de ConditionalAttribute. O exemplo supõe que a condição seja definida com a opção de compilador /define. Você pode obter resultados diferentes alterando a opção do compilador. Opcionalmente, você pode definir as condições usando pragmas no código de exemplo em vez de identificá-las como opções do compilador.

```csharp

#define CONDITION1
//#define CONDITION2
#undef CONDITION2 // Ainda imprime o método
using System;
using System.Diagnostics;

namespace Conditional_Atributo
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Calling Method1");
            Method1(3);
            Console.WriteLine("Calling Method2");
            Method2();

            Console.WriteLine("Using the Debug class");
            Debug.Listeners.Add(new ConsoleTraceListener());
            Debug.WriteLine("DEBUG is defined");

            Console.ReadKey();
        }

        [Conditional("CONDITION1")]
        public static void Method1(int x)
        {
            Console.WriteLine("CONDITION1 is defined");
        }

        [Conditional("CONDITION1"), Conditional("CONDITION2")]
        public static void Method2()
        {
            Console.WriteLine("CONDITION1 or CONDITION2 is defined");
        }
    }
}
/*
Quando compilado como mostrado, o aplicativo produz a seguinte saída.
Calling Method1
CONDITION1 is defined
Calling Method2
CONDITION1 or CONDITION2 is defined
Using the Debug class
DEBUG is defined

Se comentar as declarações define:
Calling Method1
Calling Method2
Using the Debug class
DEBUG is defined
*/
```

Um atributo também possui um destino específico ao qual se aplica. Pode ser um atributo aplicado a um assembly inteiro, uma classe, um método específico ou mesmo um parâmetro de um método.Se você olhar para o AssemblyInfo.cs de uma nova biblioteca de classes, poderá ver como o destino é explicitamente especificado.
<p align="center">
  <img src="https://raw.githubusercontent.com/shyoutarou/Exam-70-483_Criar_usar_tipos/master/.github/Condicional_Atributo.png" alt="Image" width="100%" />
</p>


Esses atributos são todos aplicados à montagem atual e descrevem alguns metadados sobre a montagem.

### Atributos de leitura (Veja mais exemplos na seção Reflexion, mais abaixo)

A aplicação de um atributo não é útil se você não puder recuperá-lo. Felizmente, o .NET Framework oferece suporte para leitura de atributos por meio de um processo chamado reflexão. A classe System.Attribute, da qual todos os outros atributos herdam, define alguns métodos estáticos que podem ser usados para verificar se um atributo é aplicado e para obter a instância atual de um atributo para que você possa inspecioná-lo ainda mais.

Suponha que você queira verificar se uma classe tem o atributo Serializable aplicado. Você pode fazer isso chamando o método estático IsDefined no Attribute, como mostra abaixo.
```csharp
if (Attribute.IsDefined(typeof(Person), typeof(SerializableAttribute)))
{
    Console.WriteLine("Attribute.IsDefined as SerializableAttribute");
}
```

Você também pode recuperar a instância específica de um atributo para poder ver suas propriedades. O código abaixo mostra como você pode obter o ConditionalAttribute do exemplo anterior Conditional_Atributo.
```csharp
public class  class Teste
{
    [ConditionalAttribute("CONDITION1")]
    public static void MetodoVoid(string txt)
    {
        Debug.WriteLine("DEBUG method.Invoke.MetodoVoid: " + txt);
    }
}

//Call methods with reflection
MethodInfo[] methods = typeof(DLL_Example.class Teste).GetMethods(BindingFlags.Static | BindingFlags.Public);
foreach (MethodInfo method in methods)
{
    ConditionalAttribute conditional =
    Attribute.GetCustomAttribute(method, typeof(ConditionalAttribute)) as ConditionalAttribute;

    if (conditional != null)
    {
        //I can get the string of the condition;
        string conditionString = conditional.ConditionString;

        //If the method has a ConditionalAttribute
        if (conditionString != null)
        {
            method.Invoke(null, newobject[] { conditionString });
        }
    }
}
```

Os métodos GetAttribute e GetAttributes têm várias sobrecargas para que você possa inspecionar atributos de um assembly, método, módulo ou parâmetro.

### Atributo personalizado (Custom)

Os Attributes são um tipo de metadados para marcar o código C# (tipos, métodos, propriedades e assim por diante). Os Attributes podem ser usados com reflexão para consultar o código C# em tempo de execução, para geração de código ou no editor em tempo de compilação de várias maneiras (por exemplo, para ocultar/procurar controles de forma de janela na barra de ferramentas).

Em termos de programação, os atributos são classes C#, herdadas do tipo "Attribute". Ao criar um atributo customizado, é uma regra sufixar seu nome de classe com "Attribute". Uma classe de atributo customizado pode ter também propriedades podem ser declaradas. Somente propriedade pública com get; set; pode declarar na classe de atributo. 

Um construtor pode ser declarado em uma classe de atributo personalizado da mesma maneira que é declarado em qualquer classe C#. O construtor pode conter um parâmetro que também pode ser um parâmetro opcional. Ao especificar um parâmetro opcional no construtor, podemos ter a vantagem de passar um valor ou descartá-lo. Esse recurso do uso do construtor no atributo customizado é útil ao fornecer informações opcionais.

Por exemplo, veja o trecho de código abaixo, onde MyCustomAttribute é o nome de um atributo personalizado que herda uma classe "Attribute".

```csharp

//Tells MyCustomAttribute can only be use on a Class, Method and Property
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method | AttributeTargets.Property)]
class MyCustomAttribute : Attribute
{
    public string  Nome { get; set; }
    public int Idade { get; set; }
    public decimal Altura { get; set; }

    //public MyCustomAttribute()
    //{

    //}

    public MyCustomAttribute(string name, int age = -1)
    {
        this.Nome = name;
        this.Idade = age;
    }
}
```

Os valores das propriedades podem ser atribuídos quando uma instância do atributo personalizado é anexada a qualquer elemento de código C#.

```csharp
[MyCustom(Nome = "Ali Asad", Idade = 30)]
```

No parâmetro AttributeUsage, usamos AttributeTargets para restringir um atributo personalizado a ser aplicado apenas nessas enumerações (classe, método, propriedade etc.). Use um tubo de barra vertical ```|``` para adicionar mais de um AttributeTargets no construtor de AttributeUsage. A seguir, são apresentadas algumas enumerações de AttributeTargets usadas com freqüência, úteis para aplicar restrições no código C#.


|  |  | AttributeTargets |  |  |
|:----------|------|------|------|------|
| All | Class | Constructor | Delegate | Enum |
| Field  |  Interface | Method | Property | Struct |
	

Abaixo temos uma implementação onde exemplifica o uso do atributo personalizado:

```csharp

namespace Reflection_CustAttribute
{
    class MyCustomAttribute : Attribute
    {
    }

    [MyCustom] //Class, Marked with Custom Attribute
    class Person
    {
        //Property, Without Custom Attribute
        public int ID { get; set; }
        [MyCustom] //Property, Marked with Custom Attribute
        public int Age { get; set; }
        //Method, Without Custom Attribute
        public void Bye()
        {
            Console.WriteLine("Bye, world!");
        }
        [MyCustom] //Method, Marked with Custom Attribute
        public void Hi()
        {
            Console.WriteLine("Hi, world!");
        }
    }

    //Class, Without Custom Attribute
    class Machine
    {
        public int ID { get; set; }
    }

    class Program
    {
        static void Main(string[] args)
        {
            Assembly assembly = Assembly.GetExecutingAssembly();
            //Get all types that are marked with 'MyCustomAttribute'
            var types = (from t in assembly.GetTypes()
            where t.GetCustomAttributes<MyCustomAttribute>().Count() > 0
            select t);

            foreach (var type in types)
            {
                Console.WriteLine(type.Name);
                //Get all properties which are marked with 'MyCustomAttribute'
                var properties = (from p in type.GetProperties()
                where p.GetCustomAttributes<MyCustomAttribute>().Count() > 0
                select p);

                foreach (var property in properties)
                {
                    Console.WriteLine("\tProperty Name: {0}", property.Name);
                }
                //Get all methods which are marked with 'MyCustomAttribute'
                var methods = (from m in type.GetMethods()
                where m.GetCustomAttributes<MyCustomAttribute>().Count() > 0
                select m);

                foreach (var method in methods)
                {
                    Console.WriteLine("\tMethod Name: {0}()", method.Name);
                }

                Console.ReadKey();
            }
        }
    }
}

Person
        Property Name: Age
        Method Name: Hi()
Ali Asad - -1
```
Observe que [MyCustom] = [MyCustomAttribute] porque o .NET Framework já sabe que "Attribute" é um sufixo, portanto, é um recurso do C# que permite ignorar o sufixo. No código acima, um atributo personalizado do nome "MyCustomAttribute" é criado. Este atributo [MyCustom] está marcado em uma classe, propriedade e método. No método principal, usando reflexão, todos os tipos, propriedades e métodos que foram marcados com "MyCustomAttribute" pode ser encontrado usando o método GetCustomAttributes<TAttribute>(). Os atributos que não estão marcados são ignorados e não são impressos no final.

Usando o método Attribute.GetCustomAttribute(), o valor armazenado nas propriedades de um atributo pode ser recuperado. Para recuperar uma instância de atributo customizado de uma classe, precisamos especificar que tipo de atributo é e a que tipo de classe ele está associado, usando o operador typeof ou o método getType().

### Atributos xUnit

O xUnit (uma estrutura popular de teste de unidade) permite categorizar seus testes de unidade aplicando um atributo a eles.
<p align="center">
  <img src="https://raw.githubusercontent.com/shyoutarou/Exam-70-483_Criar_usar_tipos/master/.github/xUnit.png" alt="Image" width="100%" />
</p>


Este pacote (xunit) é chamado de meta-pacote; isto é, é um pacote que existe apenas para que você possa obter referências a vários outros pacotes. Em particular, ele traz pacotes que incluem a estrutura de teste de unidade principal e a estrutura de asserção. Se você abrir o packages.config, verá todos os pacotes que são referenciados:
```csharp
<?xmlversion="1.0"encoding="utf-8"?>
<packages>
<packageid="xunit"version="2.4.1"targetFramework="net461" />
<packageid="xunit.abstractions"version="2.0.3"targetFramework="net461" />
<packageid="xunit.analyzers"version="0.10.0"targetFramework="net461" />
<packageid="xunit.assert"version="2.4.1"targetFramework="net461" />
<packageid="xunit.core"version="2.4.1"targetFramework="net461" />
<packageid="xunit.extensibility.core"version="2.4.1"targetFramework="net461" />
<packageid="xunit.extensibility.execution"version="2.4.1"targetFramework="net461" />
</packages>
```

Quando você criou o projeto, o Visual Studio criou automaticamente um arquivo chamado Class1.cs e o abriu para você. Dentro desta classe, adicione alguns testes:

```csharp

namespace xUnitClassLibrary
{
    public class  Class1
    {
        [Fact]
        public void PassingTest()
        {
            Assert.Equal(4, Add(2, 2));
        }

        [Fact]
        public void FailingTest()
        {
            Assert.Equal(5, Add(2, 2));
        }

        int Add(int x, int y)
        {
            return x + y;
        }
    }
}
```


Compile a solução para garantir que o código seja compilado. Agora que você escreveu o primeiro teste, precisamos de uma maneira de executá-lo. Vamos instalar o pacote NuGet com o console runner.

<p align="center">
  <img src="https://raw.githubusercontent.com/shyoutarou/Exam-70-483_Criar_usar_tipos/master/.github/NuGet.png" alt="Image" width="100%" />
</p>
  

Diferente do pacote anterior (que adicionou referências à estrutura de teste de unidade), esse pacote é conhecido como pacote em nível de solução. Em vez de ter assemblies para referência, ele adiciona algumas ferramentas na pasta da solução. Usaremos uma dessas ferramentas - o console runner- para executar seus testes de unidade.

Abra um prompt de comando ou a janela de comando do PowerShell. Na janela, navegue até a pasta raiz da sua solução. Para executar o console runner, use um comando como o destacado abaixo. Você deve ver uma saída semelhante a esta:
```csharp
packages\xunit.runner.console.2.4.1\tools\net46\xunit.console xUnitClassLibrary\bin\Debug\xUnitClassLibrary.dll
```

<p align="center">
  <img src="https://raw.githubusercontent.com/shyoutarou/Exam-70-483_Criar_usar_tipos/master/.github/xUnitClassLibrary.png" alt="Image" width="100%" />
</p>
 

O console runner tem várias opções de linha de comando, que incluem opções para paralelização, filtragem de teste e relatório de resultados. Para saber mais sobre as opções do corredor do console, execute o corredor do console sem opções de linha de comando. Agora que executamos seus primeiros testes de unidade, vamos apresentar mais uma maneira de escrever testes: usando teorias.

### Escreva sua primeira teoria

Você deve estar se perguntando por que seus primeiros testes de unidade usam um atributo chamado [Fact] em vez de um com um nome mais tradicional como Test. O xUnit.net inclui suporte para dois tipos principais de testes de unidade: fatos e teorias. Ao descrever a diferença entre fatos e teorias, gostamos de dizer:
- Fatos são testes sempre verdadeiros. Eles testam condições invariantes.
- Teorias são testes que só são verdadeiros para um conjunto específico de dados.

Um bom exemplo deste teste de algoritmos numéricos. Digamos que você queira testar um algoritmo que determine se um número é ímpar ou não. Se você estiver escrevendo os testes do lado positivo (números ímpares), a inserção de números pares no teste pode causar falhas, e não porque o teste ou o algoritmo esteja errado. Vamos adicionar uma teoria aos nossos fatos existentes (incluindo alguns dados incorretos, para que possamos ver falhas):

```csharp

//=== SECOND TEST EXECUTION SUMMARY ===
[Theory]
[InlineData(3)]
[InlineData(5)]
[InlineData(6)]
public void MyFirstTheory(int value)
{
    Assert.True(IsOdd(value));
}

bool IsOdd(int value)
{
    return value % 2 == 1;
}
```


Desta vez, quando compilamos e executamos os testes, vemos uma falha, para nossa teoria que foi dada 6:

<p align="center">
  <img src="https://raw.githubusercontent.com/shyoutarou/Exam-70-483_Criar_usar_tipos/master/.github/testesfalha.png" alt="Image" width="100%" />
</p>

 
Embora tenhamos escrito apenas três métodos de teste, o corredor do console realmente executou 5 testes; isso ocorre porque cada teoria com seu conjunto de dados é um teste separado. Observe também que o corredor informa exatamente qual conjunto de dados falhou, porque inclui os valores dos parâmetros no nome do teste.

Se você possui o Visual Studio Community (ou uma versão paga do Visual Studio), pode executar os testes do xUnit.net no executor de testes interno do Visual Studio (denominado Test Explorer). Infelizmente, isso não inclui as edições Express do Visual Studio (você deve atualizar para o Community Edition).
<p align="center">
  <img src="https://raw.githubusercontent.com/shyoutarou/Exam-70-483_Criar_usar_tipos/master/.github/CommunityEdition.png" alt="Image" width="100%" />
</p>
 

Verifique se o Test Explorer está visível (vá para Teste> Windows> Test Explorer). 
<p align="center">
  <img src="https://raw.githubusercontent.com/shyoutarou/Exam-70-483_Criar_usar_tipos/master/.github/TestExplorer.png" alt="Image" width="500px" />
</p>
  

Toda vez que você compila seu projeto, o corredor descobre testes de unidade no seu projeto. Após um momento de descoberta, você deverá ver a lista de testes descobertos:
<p align="center">
  <img src="https://raw.githubusercontent.com/shyoutarou/Exam-70-483_Criar_usar_tipos/master/.github/testesdescobertos.png" alt="Image" width="100%" />
</p>


Você pode clicar em um teste com falha para ver a mensagem de falha e o rastreamento da pilha. Você pode clicar nas linhas de rastreamento da pilha para levá-lo diretamente para a linha de código com falha.

Às vezes, precisamos apenas executar um tipo específico de testes e não outros. Para poder fazer isso, precisamos de algum mecanismo para categorizar nossos testes. O xUnit possui um mecanismo interno para esse chamado Trait. O atributo Trait recebe dois argumentos. O primeiro é o nome real da categoria e o segundo argumento é a subseção que inclui a categoria. Por exemplo, temos a categoria Category como chave e, para o valor, temos "Unit Test" e "Integration Test". 
```csharp
[Fact]
[Trait("Category", "Unit Test")]
public void PassingTest()
{
    Assert.Equal(4, Add(2, 2)); //OK
}

[Fact]
[Trait("Category", "Integration Test")]
public void FailingTest()
{
    Assert.Equal(5, Add(2, 2)); //Failed
}
```

O uso do atributo Trait funciona perfeitamente, exceto que você precisa digitar a Categoria e o Valor manualmente sempre. Esse é um trabalho repetitivo e propenso a erros que você deseja evitar o máximo possível. 

### Expressões CodeDom 

Além de inspecionar tipos em tempo de execução por meio de reflexão, o C# também oferece suporte para gerar código em tempo de execução. Uma maneira de fazer isso é através do CodeDOM. Você pode usar o CodeDOM para criar um gráfico de objeto que pode ser convertido em um arquivo de origem ou em um assembly binário que pode ser executado.

Os cenários de uso típicos para usar o CodeDOM envolvem a geração de código para ASP.NET, serviços da Web, assistentes de código ou designers. Com o CodeDOM você pode representar a estrutura lógica de um trecho de código independente da sintaxe específica do idioma usada. Por exemplo, você pode usar o CodeDOM para criar um arquivo de origem na sintaxe do Visual Basic, C# ou JScript.

Toda vez que você cria o mesmo código repetidamente com algumas pequenas modificações, ou seja, precisa automatizar as tarefas de codificação repetitivas ou aplicar padrões em seus projetos, vai utilizar o CodeDOM. Esta seção demonstrará como criar um arquivo de classe usando o CodeDOM que contém campos, propriedades e métodos. A estrutura típica de uma classe no C# contém os seguintes elementos:
- Arquivo de texto que contém o código da classe
- Conjunto de instruções using
- Declaração de namespace
- Declaração de nome de classe
- Conjunto de campos e propriedades
- Conjunto de métodos, que contêm lógica com estruturas em loop e expressões lógicas, como instruções if e switch.

O CodeDOM está localizado no namespace System.CodeDom. Você pode pensar no seu arquivo de origem como uma árvore com contêineres. Você tem um contêiner superior (chamado CodeCompileUnit) que contém outros elementos, como namespaces, classes, métodos e instruções individuais. Se você deseja gerar um aplicativo simples Hello World, é necessário criar um CodeCompileUnit, um namespace, uma classe e o método Main do seu programa que chamará Console.WriteLine como no exemplo abaixo.

```csharp
 static void Main(string[] args)
{
    CodeCompileUnit compileUnit = new CodeCompileUnit();
    CodeNamespace myNamespace = new CodeNamespace("MyNamespace");
    myNamespace.Imports.Add(new CodeNamespaceImport("System"));
    CodeTypeDeclaration myClass = new CodeTypeDeclaration("MyClass");
    CodeEntryPointMethod start = new CodeEntryPointMethod();
    CodeMethodInvokeExpression cs1 = new CodeMethodInvokeExpression(
    new CodeTypeReferenceExpression("Console"), "WriteLine", new CodePrimitiveExpression("Hello World!"));

    compileUnit.Namespaces.Add(myNamespace);
    myNamespace.Types.Add(myClass);
    myClass.Members.Add(start);
    start.Statements.Add(cs1);

    CSharpCodeProvider provider = new CSharpCodeProvider();
    using (StreamWriter sw = new StreamWriter("HelloWorld.cs", false))
    {
        IndentedTextWriter tw = new IndentedTextWriter(sw, " ");
        provider.GenerateCodeFromCompileUnit(compileUnit, tw,
        new CodeGeneratorOptions());
        tw.Close();
    }

    Console.ReadKey();
}
```
<p align="center">
  <img src="https://raw.githubusercontent.com/shyoutarou/Exam-70-483_Criar_usar_tipos/master/.github/HelloWorld.png" alt="Image" width="100%" />
</p>

A saída gerada no HelloWorld.cs é mostrada abaixo:

<p align="center">
  <img src="https://raw.githubusercontent.com/shyoutarou/Exam-70-483_Criar_usar_tipos/master/.github/HelloWorldoutput.png" alt="Image" width="100%" />
</p>

Neste próximo exemplo, iremos examinar passo-a-passo como utilizar o CodeDOM para gerar a seguinte classe:

```csharp

using System;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.IO;
using System.Reflection;

class Calculator
{
    private double _x;
    private double _y;

    public double X
    {
        get { return this._x; }
        set { this._x = value; }
    }

    public double Y
    {
        get { return this._y; }
        set { this._y = value; }
    }

    public double Divide()
    {
        if (this.Y == 0)
        return 0;
        else
        return this.X / this.Y;
    }

    public double Exponent(double power)
    {
        return Math.Pow(this.X, power);
    }
}
```

Essa é uma classe simples chamada Calculator, que está no espaço de nome Reflexão, contém dois campos, duas propriedades e dois métodos. As seções a seguir demonstram quais classes no CodeDOM você deve usar para criar a classe dinamicamente. 

### CodeCompileUnit 

A classe CodeCompileUnit é a classe de nível superior que é o contêiner para todos os outros objetos da classe que você deseja gerar. Pense nisso como a classe que representa o arquivo que contém seu código. O código a seguir é usado para criar uma instância da classe CodeCompileUnit: 

CodeCompileUnit codeCompileUnit = new CodeCompileUnit();

### CodeNamespace e CodeNamespaceImport 

O próximo passo é adicionar o namespace. A classe CodeNamspace é usada para representar o namespace . O construtor usa o namespace  como parâmetro. 

```csharp
CodeNamespace codeNamespace = new CodeNamespace("Reflection");
```

Agora que você possui um namespace, pode anexar as instruções using. Normalmente, quando você cria um arquivo de classe, as instruções using estão acima da declaração do namespace, mas ainda funcionam se você as adicionar após o namespace. A classe CodeNamespaceImport é usada para definir o namespace que você gostaria de importar. Em C# você usa a palavra-chave using, mas no VB.NET você usaria a palavra-chave imports. Ao usar o CodeDOM, você não precisa se preocupar com a palavra-chave correta.
```csharp
codeNamespace.Imports.Add(new CodeNamespaceImport("System"));
codeNamespace.Imports.Add(new CodeNamespaceImport("System.CodeDom"));
codeNamespace.Imports.Add(new CodeNamespaceImport("System.CodeDom.Compiler"));
codeNamespace.Imports.Add(new CodeNamespaceImport("System.IO"));
codeNamespace.Imports.Add(new CodeNamespaceImport("System.Reflection"));
```

### CodeTypeDeclaration

O próximo passo é declarar a classe. Isso é feito usando a classe CodeTypeDeclaration.

```csharp
CodeTypeDeclaration targetClass = new CodeTypeDeclaration("Calculator");
targetClass.IsClass = true;
targetClass.TypeAttributes = TypeAttributes.Public;

codeNamespace.Types.Add(targetClass);
codeCompileUnit.Namespaces.Add(codeNamespace);
```


O código anterior cria uma instância da classe CodeTypeDeclaration e define o atributo IsClass como true, que informa ao .NET Framework para gerar uma declaração de classe. A propriedade TypeAttributes permite definir atributos como público, privado e estático. Eles podem ser combinados usando o operador bit a bit (|). Depois que a classe é definida, você precisa adicioná-lo à coleção Types do namespace. O código anterior produz a seguinte saída:

```csharp
class Calculator
{
}
```

### CodeMemberField

O próximo passo é adicionar os campos à turma. Isso é feito usando a classe CodeMemberField. Você simplesmente cria uma instância da classe e define sua propriedade Name, define a propriedade Type e a adiciona à coleção Members do objeto CodeTypeDeclaration. O código a seguir cria dois campos, _x e _y, ambos declarados como um duplo:

```csharp
//Create the fields
CodeMemberField xField = new CodeMemberField();
xField.Name = "_x";
xField.Type = new CodeTypeReference(typeof(double));
targetClass.Members.Add(xField);

CodeMemberField yField = new CodeMemberField();
yField.Name = "_y";
yField.Type = new CodeTypeReference(typeof(double));
targetClass.Members.Add(yField);
```

O código anterior produz a seguinte saída:

```csharp
private double _x;
private double _y;
```

### CodeMemberProperty

O próximo passo é criar as propriedades para os campos xe y. Você usa uma classe CodeMemberProperty para criar uma propriedade e gerar os métodos get e set. O código a seguir cria as propriedades X e Y na classe Calculadora:

```csharp
//Create the properties
CodeMemberProperty xProperty = new CodeMemberProperty();
xProperty.Attributes = MemberAttributes.Public | MemberAttributes.Final;
xProperty.Name = "X";
xProperty.HasGet = true;
xProperty.HasSet = true;
xProperty.Type = new CodeTypeReference(typeof(System.Double));
xProperty.GetStatements.Add(new CodeMethodReturnStatement(new CodeFieldReferenceExpression(new CodeThisReferenceExpression(), "_x")));
xProperty.SetStatements.Add(new CodeAssignStatement(new CodeFieldReferenceExpression(new CodeThisReferenceExpression(), "_x"), new CodePropertySetValueReferenceExpression()));
targetClass.Members.Add(xProperty);

CodeMemberProperty yProperty = new CodeMemberProperty();
yProperty.Attributes = MemberAttributes.Public | MemberAttributes.Final;
yProperty.Name = "Y";
yProperty.HasGet = true;
yProperty.HasSet = true;
yProperty.Type = new CodeTypeReference(typeof(System.Double));
yProperty.GetStatements.Add(new CodeMethodReturnStatement(new CodeFieldReferenceExpression(new CodeThisReferenceExpression(), "_y")));
yProperty.SetStatements.Add(new CodeAssignStatement(new CodeFieldReferenceExpression(new CodeThisReferenceExpression(), "_y"), new CodePropertySetValueReferenceExpression()));
targetClass.Members.Add(yProperty);
```

A classe CodeMemberProperty possui duas propriedades (HasGet e HasSet) que você precisa definir como true para que o gerador de código possa criar os acessadores Get e Set. A propriedade de coleção GetStatements é usada para adicionar o código ao acessador Get. Neste exemplo, o método Get retorna o campo this.x. A classe CodeThisReferenceExpression é usada porque em C# você usa isso; no VB você me usa. O gerador de código sabe qual palavra-chave usar ao gerar o código. A propriedade de coleção SetStatements contém o código para definir o campo this.x. Nesse caso, você precisa criar um CodeAssignStatement junto com o CodePropertySetValueReferenceExpression. O código precedente produz a seguinte saída:

```csharp
public double X
{
get { return this._x; }
set { this._x = value; }
}

public double Y
{
get { return this._y; }
set { this._y = value; }
}
```

### CodeMemberMethod

O próximo passo é criar o método Divide. Para criar métodos usando o CodeDOM, você precisa usar a classe CodeMemberMethod. O código a seguir cria uma instância da classe CodeMemberMethod, nomeia o método Divide, define o tipo de retorno como duplicado e define seus atributos como público e final. Se você deseja definir outros atributos, como estático, virtual ou novo, use o operador bit a bit para concatenar os atributos.

```csharp
CodeMemberMethod divideMethod = new CodeMemberMethod();
divideMethod.Name = "Divide";
divideMethod.ReturnType = new CodeTypeReference(typeof(double));
divideMethod.Attributes = MemberAttributes.Public | MemberAttributes.Final;
```

 Agora que a assinatura do método está definida, você precisa criar o código para o corpo do método. Ométodo Divide verifica se a propriedade Y é 0 e retorna 0 ou o quociente. Se a lógica for criada usando a classe CodeConditonStatement.

```csharp
CodeConditionStatement ifLogic = new CodeConditionStatement();
ifLogic.Condition = new CodeBinaryOperatorExpression(new CodeFieldReferenceExpression(new CodeThisReferenceExpression(), yProperty.Name), CodeBinaryOperatorType.ValueEquality,
new CodePrimitiveExpression(0));
ifLogic.TrueStatements.Add(new CodeMethodReturnStatement(new CodePrimitiveExpression(0)));
ifLogic.FalseStatements.Add(new CodeMethodReturnStatement(
new CodeBinaryOperatorExpression(
new CodeFieldReferenceExpression(new CodeThisReferenceExpression(), xProperty.Name),
        CodeBinaryOperatorType.Divide,
new CodeFieldReferenceExpression(new CodeThisReferenceExpression(), yProperty.Name))));
divideMethod.Statements.Add(ifLogic);
targetClass.Members.Add(divideMethod);
```

Como você pode ver, a classe CodeConditonStatement possui uma propriedade Condition que é uma classe CodeBinaryOperatorExpression. Esta classe é usada para criar uma expressão binária. Neste exemplo, a expressão é igual a (this.Y == 0). A classe CodeBinaryOperatorExpression também possui uma propriedade TrueStatements e FalseStatements que permite criar o código que será gravado para as condições verdadeiras e falsas. O código anterior cria a seguinte saída:

```csharp
public double Divide()
{
if (this.Y == 0)
return 0;
else
return this.X / this.Y;
}
```

### CodeParameterDeclarationExpression e CodeMethodInvokeExpression

O próximo passo é criar o método Exponent. Esse método pega um parâmetro chamado power e retorna this.Y aumentado para esse power.

```csharp
CodeMemberMethod exponentMethod = new CodeMemberMethod();
exponentMethod.Name = "Exponent";
exponentMethod.ReturnType = new CodeTypeReference(typeof(double));
exponentMethod.Attributes = MemberAttributes.Public | MemberAttributes.Final;

CodeParameterDeclarationExpression powerParameter = new CodeParameterDeclarationExpression(typeof(double), "power");
exponentMethod.Parameters.Add(powerParameter);

CodeMethodInvokeExpression callToMath = new CodeMethodInvokeExpression(
new CodeTypeReferenceExpression("System.Math"),
"Pow", new CodeFieldReferenceExpression(new CodeThisReferenceExpression(), xProperty.Name), new CodeArgumentReferenceExpression("power"));

exponentMethod.Statements.Add(new CodeMethodReturnStatement(callToMath));
targetClass.Members.Add(exponentMethod);
```

Você usa a classe CodeParameterDeclarationExpression para criar o parâmetro power. A classe CodeMethodInvokeExpression é usada para chamar um método e passar um parâmetro para o método. O código anterior produz a seguinte saída:

```csharp
public double Exponent(double power)
{
    return Math.Pow(this.X, power);
}

```

### CodeDOMProvider

O último passo é gerar o arquivo de classe. Você usa a classe CodeDOMProvider para criar o arquivo em C#, VB ou JScript. Essa classe possui um método chamado GenerateCodeFromCompileUnit que usa uma classe CodeCompileUnit, TextWriter e CodeGeneratorOptions como parâmetros. A classe CodeGeneratorOptions possui propriedades que permitem controlar a formatação do seu código gerado automaticamente. O exemplo a seguir informa ao compilador para usar o espaçamento de linha única entre as declarações do membro. Definir a propriedade BracingStyle como "C" coloca os colchetes, {}, em linhas separadas.

```csharp
CodeDomProvider provider = CodeDomProvider.CreateProvider("CSharp");
CodeGeneratorOptions options = new CodeGeneratorOptions();
options.BlankLinesBetweenMembers = false;
options.BracingStyle = "C";

using (StreamWriter sourceWriter = new StreamWriter(@"c:\CodeDom\Calculator." + provider.FileExtension))
{
    provider.GenerateCodeFromCompileUnit(codeCompileUnit, sourceWriter, options);
}
```

### EXPRESSÕES LAMBDA

Funções Lambda foram introduzidas no C# 3.0. Você pode pensar em uma expressão lambda como um método compacto para criar um método anônimo. O método anônimo é essencialmente um método sem nome, pode escrever um método anônimo para não ter o trabalho de criar a assinatura em métodos pequenos e usados em escopo limitado. Além disso, você pode passar um método anônimo para outros métodos para alterar dinamicamente como esses métodos se comportam. Este conceito é extremamente importante para entender antes de abordar o conceito de LINQ. Expressões lambda são usadas em qualquer lugar no LINQ.

### Delegates e Lambda

Antes de explorar as expressões lambda, comece com o básico. Um delegado é um tipo que faz referência a um método. Ao declarar um delegado, você especifica a assinatura do método que deseja referenciar. Por exemplo, crie uma nova classe chamada LambdaExpressione adicione o seguinte método que pega um parâmetro de string e o grava na janela do console:

```csharp
public class LambdaExpression
{
    public static void WriteToConsoleForward(string stringToWrite)
    {
        Console.WriteLine("This is my string: {0}", stringToWrite);
    }
}
```


Se você quiser fazer referência a esse método, primeiro crie um delegado com a mesma assinatura. Observe que o tipo de retorno é nulo e o tipo do parâmetro é uma string que corresponde à assinatura do método WriteToConsoleForward. Agora que você tem um representante, você precisa associar uma variável desse tipo ao método

```csharp
delegate void MyFirstDelegate(string s);

 static void Main(string[] args)
{
    MyFirstDelegate myFirstDelegate = new MyFirstDelegate(LambdaExpression.WriteToConsoleForward);
    myFirstDelegate("Hello World"); // This is my string: Hello World
}
```

A variável myFirstDelegate contém essencialmente uma referência ao método. Agora você pode chamar o método usando a variável myFirstDelegate e passando um parâmetro. Agora crie um segundo método na classe LambdaExpression que usa uma string como parâmetro e grava a string para trás no console.

```csharp
public static void WriteToConsoleBackwards(string stringToWrite)
{
    char[] charArray = stringToWrite.ToCharArray();
    Array.Reverse(charArray);

    Console.WriteLine(string.Format("Write backwards: {0}", newstring(charArray)));
}
```

Ambos os métodos têm a mesma assinatura, portanto, você pode criar um único representante para fazer referência a qualquer método. Agora crie outro método chamadoWriteToConsole que usa o delegado como parâmetro e chame o método.

```csharp
delegate void MyFirstDelegate(string s);

 static void Main(string[] args)
{
    var myLocalString = "Hello World";

    WriteToConsole(LambdaExpression.WriteToConsoleForward, myLocalString); // Hello World
    WriteToConsole(LambdaExpression.WriteToConsoleBackwards, myLocalString); // dlroW olleH
}

 static void WriteToConsole(MyFirstDelegate myDelegate, string stringToWrite)
{
    myDelegate(stringToWrite);
}
```

Você também pode adicionar  ou remover um método de uma lista de chamadas usando o operador de atribuição de incremento (+ ou +=) e decremento (- ou -=). 

```csharp
MyFirstDelegate myFirstDelegate2 = LambdaExpression.WriteToConsoleForward;
myFirstDelegate2 += LambdaExpression.WriteToConsoleBackwards;
myFirstDelegate2(myLocalString);
```


Quando você atribui um método a um delegado, a assinatura do método não precisa corresponder exatamente ao delegado. Isso é chamado de covariância e contravariância.
- **Covariância**: permite que você tenha um método com um tipo de retorno mais derivado do que o tipo de retorno do delegado. Portanto, o tipo de retorno do delegado pode ser uma classe base, e o tipo de retorno do método pode ser um tipo que herda da classe base.
- **Contravariância**: permite tipos de parâmetro menos derivados que os tipos de parâmetro do delegado. Portanto, os parâmetros do delegado podem ser uma classe base, mas os parâmetros do método podem ser uma classe derivada da classe base.

O exemplo abaixo mostra um exemplo de covariância.

```csharp
public delegate TextWriter CovarianceDel();

 static void Main(string[] args)
{
    CovarianceDel del_covarinace;
    del_covarinace = MethodStream;
    del_covarinace = MethodString;
var retorno = del_covarinace();
}

public static  StreamWriter MethodStream() { returnnull; }
public static  StringWriter MethodString() { returnnull; }

```

Como o StreamWriter e o StringWriter herdam do TextWriter, você pode usar o CovarianceDel com os dois . TextWriter é a classe base abstrata de StreamWriter e StringWriter, que gravam caracteres em fluxos e cadeias, respectivamente. Crie uma instância de TextWriter para gravar um objeto em uma cadeia de caracteres, gravar cadeias de texto em um arquivo ou serializar XML. Você também pode usar uma instância de TextWriter para gravar texto em um repositório de backup personalizado usando as mesmas APIs que você usaria para uma cadeia de caracteres ou um fluxo, ou para adicionar suporte para formatação de texto.
Um exemplo de contravariância pode ser visto abaixo.

```csharp
public delegate void ContravarianceDel(StreamWriter tw);

static void Main(string[] args)
{          
    ContravarianceDel del_contravariance = DoSomething;
    del_contravariance((StreamWriter)retorno);

    Console.ReadKey();
}

public static void DoSomething(TextWriter tw) { }
```

Como o método DoSomething pode funcionar com um TextWriter, certamente também pode funcionar com um StreamWriter. Por causa da contravariância, você pode chamar o delegado e passar uma instância do StreamWriter para o método DoSomething.

### Métodos anônimos e Lambda

Os métodos anônimos são semelhantes aos delegados, exceto que você não precisa criar o método. Você ainda cria o delegado, mas pode atribuir o método tudo dentro da mesma linha de código. Uma diferença entre um método anônimo e um delegado é que você pode fazer referência a variáveis locais que não são passadas como parâmetros. Por exemplo, o exemplo a seguir cria uma variável delegada chamada forward que não possui parâmetrose faz referência ao corpo de um método. O método pode ter quantas linhas você desejar. Em seguida, ele cria uma variável local e um método anônimo que usa a variável.

```csharp

delegate void MyAnonymousMethod();

static void Main(string[] args)
{
    var myLocalString = "Hello World";

    MyAnonymousMethod forward = delegate ()
    {
        Console.WriteLine(string.Format("This is my AnonymousMethod: {0}", myLocalString));
    };
    forward();
}
```

As expressões Lambda permitem criar uma função anônima usando sintaxe abreviada. Considere o seguinte:

```csharp
delegate double square(double x);

static void Main(string[] args)
{
    square myLambdaExpression = x => x * x;
    Console.WriteLine("X squared is {0}", myLambdaExpression(5)); // 25
}

```

A expressão lambda é x => x * x. Ao ler o código, você diria que x vai para (goes to) x vezes x. O => é chamado “goes to” operador. O lado esquerdo do operador vai para os parâmetros de entrada do seu método. O corpo do seu método vai no lado direito do vai para o operador. Nesse caso, o método pode enquadrar qualquer número que seja passado para o método. Se você precisar passar vários parâmetros, use a seguinte sintaxe:

```csharp
delegate bool GreaterThan(double x, double y);

 static void Main(string[] args)
{
    GreaterThan gt = (x, y) => x > y;
    Console.WriteLine("Is 6 greater than 5. {0}", gt(6, 5)); // True
}
```

Ao trabalhar com lambdas, você também precisará conhecer os tipos Func<> e Action. Esses tipos genéricos foram adicionados para ter alguns tipos de delegados predefinidos no .NET Framework. Você usa Action quando tem um delegado que não retorna um valor e Func quando você deseja retornar um valor. Ambos podem receber até 16 argumentos de tipo no .NET Framework 4.0.Ao combinar lambda e o tipo Func, você pode criar facilmente um tipo que retorne a soma de dois números inteiros, conforme mostrado abaixo.

```csharp
Func<int, int, int> addFunc = (x, y) => x + y;
Console.WriteLine(addFunc(2, 3)); // 5
```


O lambda é do tipo Func<int, int, int>, o que significa que ele recebe dois argumentos inteiros e retorna um int como resultado. A notação estranha => pode ser lida como "se torna" ou "para qual". O tipo addFunc pode ser lido como "x, y se torna x + y".

### Instruções Lambdas (Statement Lambdas)

Quando o método contém apenas uma única expressão, é chamado de expressão lambda. Quando você precisa de várias instruções no corpo do método, isso é chamado de Instruções lambdas. Instruções Lambdas estão entre colchetes {}. A seguir está uma expressão lambda para o método WriteToConsoleBackwardcom uma variável local:

```csharp
MyAnonymousMethod myFirstDelegate2 = () =>
{
    char[] charArray = myLocalString.ToCharArray();
    Array.Reverse(charArray);
    Console.WriteLine(string.Format("This is my string backwards: {0}", newstring(charArray)));
};
myFirstDelegate2();
```

Usando uma instrução de expressão Lambda com um parâmetro

```csharp
delegate void MyFirstDelegate(string s);

MyFirstDelegate myFirstDelegate3 = s =>
{
char[] charArray = s.ToCharArray();
    Array.Reverse(charArray);
    Console.WriteLine(string.Format("This is my string backwards: {0}", newstring(charArray)));
};
myFirstDelegate3(myLocalString);
```

Você também pode usar uma expressão lambda para passar uma função para um método. A seguir, uma expressão lambda para chamar o método WriteToConsole:

```csharp
delegate void MyFirstDelegate(string s);

 static void Main(string[] args)
{
var myLocalString = "Hello World";

    WriteToConsole(x => Console.WriteLine("Esta é minha string {0}", x), myLocalString);

    Console.ReadKey();
}

 static void WriteToConsole(MyFirstDelegate myDelegate, string stringToWrite)
{
    myDelegate(stringToWrite);
}
```

Como você pode ver, a sintaxe requer menos digitação à medida que você passa de delegar, para função anônima e para expressões lambda.

### Árvores de expressão

Ao usar lambdas, você encontrará árvores de expressão, que são representações de código em uma estrutura de dados semelhante a uma árvore. Assim como o CodeDom pode representar o código de maneira semelhante a uma árvore, as árvores de Expressão podem fazer o mesmo; eles também podem ser usados para gerar código.

Uma árvore de expressão descreve o código em vez de ser o próprio código. As árvores de expressão são muito usadas no LINQ. Ao usar o Linq To Entities para consultar um banco de dados, a consulta não é executada (como é o caso no Linq To Objects). Em vez disso, uma árvore de expressão descreve a consulta. Posteriormente, essa árvore de expressão é traduzida em uma instrução SQL que pode ser enviada ao banco de dados.

O namespace System.Linq.Expressions contém todos os tipos necessários para criar uma expressão. Você tem expressões para chamar um método e criar um novo objeto ou mesmo operações básicas, como adição ou subtração. O exemplo Hello World do CodeDOM também pode ser criado como uma árvore de expressão

```csharp
BlockExpression blockExpr = Expression.Block(
        Expression.Call(null, typeof(Console).GetMethod("Write",
new Type[] { typeof(String) }), Expression.Constant("Hello ")),
        Expression.Call(null, typeof(Console).GetMethod("WriteLine",
new Type[] { typeof(String) }), Expression.Constant("World!"))
        );

Expression.Lambda<Action>(blockExpr).Compile()(); // Hello World!
```

A expressão é criada primeiro com uma chamada para Console.Write e Console.WriteLine. Após a construção, a expressão é compilada em uma ação (porque não retorna nada) e executada.

As coisas começam a ficar mais complexas quando sua função lambda começa a se referir a variáveis declaradas fora da expressão lambda (ou a esta referência). Normalmente, quando o controle sai do escopo de uma variável, a variável não é mais válida. Mas e se um delegado se referir a uma variável local e depois retornar ao método de chamada? Agora, o delegado tem uma vida útil mais longa que a variável. Para corrigir isso, o compilador gera código que torna a vida útil da variável capturada pelo menos contanto que o delegado que vive mais tempo. Isso é chamado de encerramento (closure).

### Reflection

O namespace System.Reflection contém várias classes que permitem criar e usar dinamicamente tipos, métodos e propriedades de um aplicativo em execução. Em termos de processamento, a reflexão custa muita energia do processador porque, ao usar metadados, ela reverte todos os dados binários em dados legíveis.Ou seja, o Reflection converte informações binárias (de baixo nível) em linguagem legível por humanos (alto nível) e permite que humanos (desenvolvedores) manipulem os dados e o comportamento de um aplicativo em tempo de execução.

O Reflection é mais lenta que a execução normal do código estático. No entanto, pode oferecer uma flexibilidade que o código estático não pode fornecer. O exemplo mais básico de reflexão é obter o tipo atual de um objeto que você possui, você pode usar o método GetType () em uma instância do tipo:

```csharp
int i = 42;
System.Type type = i.GetType();

	Ou pode usar a palavra-chave typeof () e passar o nome do tipo:

System.Type myType = typeof (int);
```


Isso retorna System.Int32 como o tipo de int. System.Type é uma classe no .NET Framework que você pode usar para obter todos os tipos de metadados sobre qualquer tipo. A classe System.Type representa uma classe, interface, matriz, tipo de valor, enumeração, parâmetro, definições de tipo genérico e tipos genéricos construídos abertos ou fechados. Na maioria das vezes, você geralmente usa um Type para obter informações sobre uma classe contida em uma montagem.

```csharp
//AssmeblyQualifiedName: System.Int32, mscorlib, Version = 4.0.0.0, Culture = neutral, PublicKeyToken = b77a5c561934e089
Console.WriteLine("AssmeblyQualifiedName: {0}", myType.AssemblyQualifiedName);
Console.WriteLine("FullName: {0}", myType.FullName); //FullName: System.Int32
Console.WriteLine("IsValueType: {0}", myType.IsValueType); //IsValueType: True
Console.WriteLine("Name: {0}", myType.Name); //Name: Int32
Console.WriteLine("Namespace: {0}", myType.Namespace); //Namespace: System
```

Agora, suponha que você deseja criar um sistema de plug-in e que você tenha um diretório em seu sistema que contenha todos os plug-ins, você precisa de alguma maneira de encontrar plug-ins, obter algumas informações e executá-los e isso é impossível sem Reflection. Você pode usar Reflection para criar uma interface IPlugin personalizada que expõe membros que fornecem informações sobre o plug-in e a capacidade de carregá-lo.

```csharp
public interface IPlugin
{
    string Name { get; }
    string Description { get; }
    bool Load(Program application);
}
```


Agora que você possui uma interface base personalizada, pode criar um plug-in herdando desta interface com uma classe de plug-in específica, como mostra abaixo.

```csharp
public class MyPlugin : IPlugin
{
    public string  Name
    {
        get { return"MyPlugin"; }
    }
    
    public string  Description
    {
        get { return"My Sample Plugin"; }
    }
    
    public bool Load(Program application)
    {
        return true;
    }
}
```

Usando a reflexão, agora você pode inspecionar uma montagem e verificar se há plug-ins disponíveis. Os tipos que você recebe podem ser usados para criar uma instância do plug-in e usá-lo. O exemplo abaixo mostra como obter todos os plug-ins de um assembly com uma consulta LINQ e construí-los.

```csharp

Assembly assembly = Assembly.GetExecutingAssembly();
Assembly pluginAssembly = Assembly.Load("Reflexion_IPlugin");

Console.WriteLine(assembly.FullName == pluginAssembly.FullName);// True

var DLL_type = from type in assembly.GetTypes()
wheretypeof(IPlugin).IsAssignableFrom(type) && !type.IsInterface
select type;

foreach (Type pluginType in DLL_type)
{
    IPlugin plugin = Activator.CreateInstance(pluginType) as IPlugin;

if (plugin != null)
    Console.WriteLine(plugin.Name + " - " + plugin.Description); // MyPlugin - My Sample Plugin
}
```

O namespace System.Reflection contém várias classes que podem ser usadas para ler metadados ou invocar dinamicamente o comportamento de um tipo. A Tabela abaixo lista algumas das classes usadas com freqüência no namespace System.Reflection.

| Tipo | Descrição | 
|:----------|------|
| Assembly| Representa um arquivo DLL ou EXE e contém propriedades para o nome do assembly, classes, módulos e outro aplicativo de tempo de execução do idioma de metadados. | 
| EventInfo  |  Representa um evento definido em sua classe e contém propriedades como o nome do evento. |
| FieldInfo  |  Representa um campo definido em sua classe e contém propriedades como se o campo é público ou privado. | 
| MemberInfo  |  Abstrai os metadados sobre uma classe e pode representar um evento, um campo e assim por diante. | 
| MethodInfo  |  Representa um método definido em sua classe e pode ser usado para invocar o método. | 	
| Module  | O módulo é um arquivo que compõe a montagem. Geralmente, esse é um arquivo DLL ou EXE. | 	
| ParameterInfo  |  Representa uma declaração de parâmetro para um método ou construtor. Isso permite determinar o tipo de parâmetro, seu nome e outras propriedades. | 		
| PropertyInfo  |  Representa uma propriedade definida em sua classe e contém propriedades como o nome e o tipo da propriedade | 		
	
### Obter informações do assembly (propriedades, métodos, eventos, interfaces, campos)

A classe System.Reflection.Assembly contém métodos e propriedades usadas para ler e manipular informações de um assembly em tempo de execução.

```csharp

namespace Reflection_DemoAssembly
{
    class A { public int Random { get; set; } }
    class B : A { }

    class Program
    {
        public int Age { get; set; }
        public string  Name { get; set; }

        static void Main(string[] args)
        {
            //Get current loaded assembly
                        Assembly assembly = Assembly.GetExecutingAssembly();
            //Get Full Name of the current Assembly
            string assemblyName = assembly.FullName;

            //Getall types defined in an assembly
                        Type[] types = assembly.GetTypes();
            //Get information of each type
            foreach (Type type in types)
            {
                //Return name of a type and its base type
                Console.WriteLine("Type Name:{0}, Base Type:{1}", type.Name, type.BaseType);

                Lista_Propriedades(type);
            }

            AssemblyName[] referencedAssemblyNames = assembly.GetReferencedAssemblies();

            foreach (AssemblyName assemblyRef in referencedAssemblyNames)
            {
                Console.WriteLine(string.Format("Assembly Name: {0}", assemblyRef.Name));
                Console.WriteLine(string.Format("Assembly Version: {0}", assemblyRef.Version));
            }

            //Reflection_DemoAssembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
            Console.WriteLine(assemblyName);
            Console.ReadKey();
        }

        public static void Lista_Propriedades(Type type)
        {
            //Get all properties defined in a type
            PropertyInfo[] properties = type.GetProperties();
            foreach (PropertyInfo property in properties)
            {
                Console.WriteLine("\t{0} has {1} type",
                property.Name, property.PropertyType);
            }
        }
    }
}
```


Quando um aplicativo está em execução, ele obtém os metadados do assembly atual e lê seu nome completo. O nome completo da montagem sempre contém 4 partes, que descrevem o nome da montagem, o número da versão da montagem e a cultura da montagem, e informa se a montagem tem um nome forte (se tiver um token de chave pública associado a ela).

Uma montagem pode estar em um dos três contextos ou em nenhum contexto:
1.	**Contexto de carga**, que contém os conjuntos encontrados pela análise. Sondagem é o processo de procurar no GAC, no armazenamento do conjunto host, na pasta do conjunto de saída ou na pasta bin privada do conjunto em execução para encontrar o conjunto.
2.	**Contexto de carregamento** Isso contém os assemblies localizados no caminho passado para o método LoadFrom.
3.	**Contexto somente de reflexão**, que contém os assemblies carregados com os métodos ReflectionOnlyLoad e ReflectionOnlyLoadFrom

A classe Type contém métodos e propriedades usadas para ler e editar valores de um tipo especificado. No exemplo acima, assembly.GetTypes() retorna uma matriz de tipos não estáticos. Usando propriedades como type.Name e type.BaseType, podemos obter o nome de um tipo e seu tipo base, respectivamente.

Os métodos GetExportedTypes e GetTypes são todos usados para obter referências aos tipos definidos na montagem. (A classe System.Type será explicada em mais detalhes na próxima seção.) A diferença entre GetExportedTypes e GetTypes é que GetExportedTypes retorna apenas os tipos que são públicos. O seguinte trecho de código exibe todos os tipos definidos no assembly atualmente em execução:

No exemplo acima, criamos um método estático Lista_Propriedades que recebe um Type para, durante o tempo de execução, usarmos a reflexão para a ler todas as informações de um tipo em uma montagem, incluindo métodos, propriedades, eventos, etc.A classe PropertyInfo é usada para armazenar informações de uma propriedade. Ele contém o método e as propriedades usadas para ler e editar dados de uma propriedade. Por padrão, Type.GetProperties() retorna todas as propriedades públicas não estáticas de um tipo. Ao executarmo o código, teríamos a saída:

```csharp
Type Name:A, Base Type:System.Object
        Random has System.Int32 type
Type Name:B, Base Type:Reflection_DemoAssembly.A
        Random has System.Int32 type
Type Name:Program, Base Type:System.Object
        Age has System.Int32 type
        Name has System.String type
Reflection_DemoAssembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
```

O GetReferencesAssemblies é usado para descobrir as referências para o assembly. Isso pode ser útil ao solucionar problemas de implantação. 

```csharp
Assembly Name: mscorlib
Assembly Version: 4.0.0.0
Assembly Name: System
Assembly Version: 4.0.0.0
```

Da mesma forma que fizemos com o método estático Lista_Propriedades, podemos criar outros métodos que retornasse outras informações úteis definidos na classe System.Type como métodos, eventos, interfaces, campos etc. Por exemplo, para obtermos informações sobre os métodos:

```csharp
public static void Lista_Metodos(Type type)
{
    //Get all non-static methods of a type
    MethodInfo[] methods = type.GetMethods();
    foreach (MethodInfo method in methods)
    {
        Console.WriteLine("\tMethod Name:{0}, Return Type:{1}",

        method.Name, method.ReturnType);
    }
}
```

MethodInfo é uma classe que armazena informações de um método. A classe MethodInfo contém métodos e propriedades que são usadas para ler e editar dados de um método. Por padrão, Type.GetMethods() retorna todos os métodos públicos não estáticos de um tipo. A saída desse método ficaria:

```csharp
Type Name:A, Base Type:System.Object
        Random has System.Int32 type
        Method Name:get_Random, Return Type:System.Int32
        Method Name:set_Random, Return Type:System.Void
        Method Name:Equals, Return Type:System.Boolean
        Method Name:GetHashCode, Return Type:System.Int32
        Method Name:GetType, Return Type:System.Type
        Method Name:ToString, Return Type:System.String
```

A saída retornou também os métodos "ToString", "Equals", "GetHashCode" e "GetType" que não são definidos na classe Program. Esses métodos foram definidos na classe System.Object. Como toda classe herda a classe System.Object, o programa também mostrou esses métodos.

O método GetConstructors retorna uma matriz de objetos ConstructorInfo que você pode usar para obter informações sobre todos os construtores do tipo. O código a seguir imprime os construtores e os parâmetros para um objeto System.DataTable na janela Saída:

```csharp
DataTable myDataTable = new DataTable();
Type myDataTableType = myDataTable.GetType();
ConstructorInfo[] myDataTableConstructors = myDataTableType.GetConstructors();

for (int i = 0; i <= myDataTableConstructors.Length - 1; i++)
{
    ConstructorInfo constructorInfo = myDataTableConstructors[i];
    Debug.Print(string.Format("\nConstructor #{0}", i + 1));
    Console.WriteLine(string.Format("\nConstructor #{0}", i + 1));

    ParameterInfo[] parameters = constructorInfo.GetParameters();
    Debug.Print(string.Format("Number Of Parameters: {0}", parameters.Length));
    Console.WriteLine(string.Format("Number Of Parameters: {0}", parameters.Length));

    foreach (ParameterInfo parameter in parameters)
    {
        Debug.Print(string.Format("Parameter Name: {0}", parameter.Name));
        Debug.Print(string.Format("Parameter Type: {0}", parameter.ParameterType.Name));

        Console.WriteLine(string.Format("Parameter Name: {0}", parameter.Name));
        Console.WriteLine(string.Format("Parameter Type: {0}", parameter.ParameterType.Name));
    }
}
```

Quando o objeto Type representa uma enumeração, os métodos GetEnum permitem determinar todos os nomes e valores em uma enumeração. 

```csharp
private enum MyCustomEnum { Red = 1, White = 2, Blue = 3 }

for (int i = 1; i <= 3; i++)
{
    string enumName = myCustomEnumType.GetEnumName(i);
    Debug.Print(string.Format("{0}: {1}", enumName, i));
    Console.WriteLine(string.Format("{0}: {1}", enumName, i));
}
```

### Ler, Gravar e Invocar método de classe

O Reflection também pode ser usado para ler e gravar o valor real armazenado em uma propriedade da instância de alguma classe em tempo de execução. Para obter um valor da propriedade de um objeto especificado, utilize o operador typeof ou o método GetType para armazenar o tipo de Objeto. Depois especifique o metadados da propriedade com GetProperty. Por fim, use o método GetValue() para obter o valor da propriedade.

Para definir um valor da propriedade, são necessárias as seguintes etapas de pegar o tipo com o GetType e a da propriedade com GetProperty. Por fim, use o método SetValue(). 

Já para invocar qualquer método definido, invés de usar o GetProperty devemos utilizar o método GetMethod e o especificar o método dentro da classe e o método Invoke()  para invocar-lo. Ao usar o método InvokeMember da classe System.Type, o segundo parâmetro é BindingFlags.InvokeMethod, que aciona o método InvokeMember para invocar o método.

```csharp
namespace Reflection_Read_Write
{
    class Person
    {
        public int Age { get; set; }
        public string  FirstName { get; set; }

        public int Show()
        {
            Console.WriteLine("FirstName = {0} - Age = {1}", FirstName, Age);
            return Age;
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            var personobj = new Person { FirstName = "Sundus", Age = 21 };
            var personobj2 = new Person { FirstName = "Ali", Age = 22 };

            //Store Metadata of Person Type in Type's Object
            //return Type of 'Person' class
            Type persontype = typeof(Person);
            persontype = personobj.GetType();

            //Specify which property information is required
            //Return metadata of specified property
            PropertyInfo nameproperty = persontype.GetProperty("FirstName");

            //Specify 'instance' (personobj) of 'Type' (Person)
            //Whose 'property' (nameproperty) value is about to change
            nameproperty.SetValue(personobj, "Lakhtey");

            //Specify 'instance' (personobj) of 'Type' (Person)
            //Whose 'property' (nameproperty) value is required
            var value = nameproperty.GetValue(personobj);
            Console.WriteLine("{0} = {1}", nameproperty.Name, value); //FirstName = Lakhtey

            //Specify which method's information is required
            //Return metadata of specified method
            MethodInfo methodinfo = persontype.GetMethod("Show");

            //Provide instance (personobj) name whose method is about to invoke
            //pass parameter value 'null' if specified method has parameter
            var returnValue = methodinfo.Invoke(personobj,null);
            Console.WriteLine("Age = {0}", returnValue); // Age = 21

            returnValue = (double)persontype.InvokeMember("Multiply", BindingFlags.InvokeMethod, null, personobj, newobject[] { 4, 5 });
            Console.WriteLine(string.Format("InvokeMember Return Value: {0}", returnValue)); // InvokeMember Return Value: 20

            Console.ReadKey();
        }
    }
}

FirstName = Lakhtey
FirstName = Lakhtey - Age = 21
Age = 21
```

### Obter membros privados e membros estáticos de classe

Por padrão, a reflexão é usada para obter todos os membros públicos, mas com alguns ajustes de código também pode ser útil encontrar membros particulares de um tipo. Para obter o membro privado, especificamos a enumeração BindingFlags.NonPublic no parâmetro dos métodos Type.GetFields() e Type.GetMethods(), etc.


GetProperties() é usado para retornar informações de propriedade usando as enumerações BindingFlags; esse método pode retornar o tipo especificado de propriedades. Essas enumerações indicam que uma propriedade deve ser não pública e não estática, etc. Ao passar bandeiras de encadernação, use o pipe de barra vertical ```|``` para adicionar mais de um BindingFlag no método GetProperties().

Ao chamar GetFields, você usa a enumeração BindingFlags e pode especificar mais de um valor usando o operador bit a bit.Para obter os membros estáticos públicos de um tipoutilize BindingFlags.Public e BindingFlags.Static juntos.

```csharp
namespace Reflection_Get_Private
{
    class Person
    {
        public static string company = "Microsoft";

        private int Age { get; set; }
        private string FirstName { get; set; }
        public Person(int age, string name)
        {
            this.Age = age;
            this.FirstName = name;
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            var personobj = new Person(21, "Sundus");
            var personobj2 = new Person(22, "Ali");
            //Store Metadata of Person Type in Type's Object
            //return Type of 'Person' class
            Type persontype = personobj.GetType();
            //Pass BindingFlags to specify what kind of data member you want.
            //NonPublic = Private  || Non-Static = Instance
            PropertyInfo[] props =  persontype.GetProperties(BindingFlags.NonPublic | BindingFlags.Instance);

            foreach (PropertyInfo prop in props)
            {
                Console.WriteLine("{0} = {1}", prop.Name, prop.GetValue(personobj));
            }

            //BindingFlags.Static = Static Member || BindingFlags.Public = Public Membe
            FieldInfo[] fields = persontype.GetFields(BindingFlags.Public | BindingFlags.Static);

            foreach (FieldInfo field in fields)
            {
                Console.WriteLine("{0} = {1}", field.Name, field.GetValue(personobj));
            }

            Console.ReadKey();
        }
    }
}

Age = 21
FirstName = Sundus
company = Microsoft
```

O objeto FieldInfo também possui um método SetValue que permite alterar o valor do campo, mesmo que seja privado ou protegido. Para demonstrar, adicione o seguinte acessador da classe Person:

```csharp
private string _privateField = "Hello";

public string  PrivateField
{
    get { return _privateField; }
}
```



O código a seguir altera o valor da variável privateField e imprime seu valor na janela Saída. O método SetValue é utilizado da mesma maneira que foi feito anteriormente para setar um novo valor para propriedade.

```csharp
Type personsetprivate = typeof(Person);

var setvalue = personsetprivate.GetField("_privateField", BindingFlags.NonPublic | BindingFlags.Instance);
setvalue.SetValue(personobj, "My New Value");

//Private Field Value: My New Value
Console.WriteLine(string.Format("Private Field Value: {0}", personobj.PrivateField));

```
